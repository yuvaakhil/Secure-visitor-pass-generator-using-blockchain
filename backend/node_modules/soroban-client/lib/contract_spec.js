"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContractSpec = void 0;
var _stellarBase = require("stellar-base");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ContractSpec = exports.ContractSpec = function () {
  function ContractSpec(entries) {
    _classCallCheck(this, ContractSpec);
    _defineProperty(this, "entries", []);
    if (entries.length == 0) {
      throw new Error('Contract spec must have at least one entry');
    }
    var entry = entries[0];
    if (typeof entry === 'string') {
      this.entries = entries.map(function (s) {
        return _stellarBase.xdr.ScSpecEntry.fromXDR(s, 'base64');
      });
    } else {
      this.entries = entries;
    }
  }
  _createClass(ContractSpec, [{
    key: "getFunc",
    value: function getFunc(name) {
      var entry = this.findEntry(name);
      if (entry.switch().value !== _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value) {
        throw new Error("".concat(name, " is not a function"));
      }
      return entry.value();
    }
  }, {
    key: "funcArgsToScVals",
    value: function funcArgsToScVals(name, args) {
      var _this = this;
      var fn = this.getFunc(name);
      return fn.inputs().map(function (input) {
        return _this.nativeToScVal(readObj(args, input), input.type());
      });
    }
  }, {
    key: "funcResToNative",
    value: function funcResToNative(name, val_or_base64) {
      var val = typeof val_or_base64 === 'string' ? _stellarBase.xdr.ScVal.fromXDR(val_or_base64, 'base64') : val_or_base64;
      var func = this.getFunc(name);
      var outputs = func.outputs();
      if (outputs.length === 0) {
        var type = val.switch();
        if (type.value !== _stellarBase.xdr.ScValType.scvVoid().value) {
          throw new Error("Expected void, got ".concat(type.name));
        }
        return null;
      }
      if (outputs.length > 1) {
        throw new Error("Multiple outputs not supported");
      }
      var output = outputs[0];
      if (output.switch().value === _stellarBase.xdr.ScSpecType.scSpecTypeResult().value) {
        return this.scValToNative(val, output.result().okType());
      }
      return this.scValToNative(val, output);
    }
  }, {
    key: "findEntry",
    value: function findEntry(name) {
      var entry = this.entries.find(function (entry) {
        return entry.value().name().toString() === name;
      });
      if (!entry) {
        throw new Error("no such entry: ".concat(name));
      }
      return entry;
    }
  }, {
    key: "nativeToScVal",
    value: function nativeToScVal(val, ty) {
      var _this2 = this;
      var t = ty.switch();
      var value = t.value;
      if (t.value === _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value) {
        var udt = ty.value();
        return this.nativeToUdt(val, udt.name().toString());
      }
      if (value === _stellarBase.xdr.ScSpecType.scSpecTypeOption().value) {
        var opt = ty.value();
        if (val === undefined) {
          return _stellarBase.xdr.ScVal.scvVoid();
        }
        return this.nativeToScVal(val, opt.valueType());
      }
      switch (_typeof(val)) {
        case 'object':
          {
            var _val$constructor$name, _val$constructor;
            if (val === null) {
              switch (value) {
                case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value:
                  return _stellarBase.xdr.ScVal.scvVoid();
                default:
                  throw new TypeError("Type ".concat(ty, " was not void, but value was null"));
              }
            }
            if (val instanceof _stellarBase.xdr.ScVal) {
              return val;
            }
            if (val instanceof _stellarBase.Address) {
              if (ty.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value) {
                throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
              }
              return val.toScVal();
            }
            if (val instanceof _stellarBase.Contract) {
              if (ty.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value) {
                throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
              }
              return val.address().toScVal();
            }
            if (val instanceof Uint8Array || Buffer.isBuffer(val)) {
              var copy = Uint8Array.from(val);
              switch (value) {
                case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value:
                  {
                    var bytes_n = ty.value();
                    if (copy.length !== bytes_n.n()) {
                      throw new TypeError("expected ".concat(bytes_n.n(), " bytes, but got ").concat(copy.length));
                    }
                    return _stellarBase.xdr.ScVal.scvBytes(copy);
                  }
                case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value:
                  return _stellarBase.xdr.ScVal.scvBytes(copy);
                default:
                  throw new TypeError("invalid type (".concat(ty, ") specified for Bytes and BytesN"));
              }
            }
            if (Array.isArray(val)) {
              if (_stellarBase.xdr.ScSpecType.scSpecTypeVec().value === value) {
                var vec = ty.value();
                var elementType = vec.elementType();
                return _stellarBase.xdr.ScVal.scvVec(val.map(function (v) {
                  return _this2.nativeToScVal(v, elementType);
                }));
              } else if (_stellarBase.xdr.ScSpecType.scSpecTypeTuple().value === value) {
                var tup = ty.value();
                var valTypes = tup.valueTypes();
                if (val.length !== valTypes.length) {
                  throw new TypeError("Tuple expects ".concat(valTypes.length, " values, but ").concat(val.length, " were provided"));
                }
                return _stellarBase.xdr.ScVal.scvVec(val.map(function (v, i) {
                  return _this2.nativeToScVal(v, valTypes[i]);
                }));
              } else {
                throw new TypeError("Type ".concat(ty, " was not vec, but value was Array"));
              }
            }
            if (val.constructor === Map) {
              if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeMap().value) {
                throw new TypeError("Type ".concat(ty, " was not map, but value was Map"));
              }
              var scMap = ty.value();
              var map = val;
              var entries = [];
              var values = map.entries();
              var res = values.next();
              while (!res.done) {
                var _res$value = _slicedToArray(res.value, 2),
                  k = _res$value[0],
                  v = _res$value[1];
                var key = this.nativeToScVal(k, scMap.keyType());
                var _val = this.nativeToScVal(v, scMap.valueType());
                entries.push(new _stellarBase.xdr.ScMapEntry({
                  key: key,
                  val: _val
                }));
                res = values.next();
              }
              return _stellarBase.xdr.ScVal.scvMap(entries);
            }
            if (((_val$constructor$name = (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) !== null && _val$constructor$name !== void 0 ? _val$constructor$name : '') !== 'Object') {
              var _val$constructor2;
              throw new TypeError("cannot interpret ".concat((_val$constructor2 = val.constructor) === null || _val$constructor2 === void 0 ? void 0 : _val$constructor2.name, " value as ScVal (").concat(JSON.stringify(val), ")"));
            }
            throw new TypeError("Received object ".concat(val, "  did not match the provided type ").concat(ty));
          }
        case 'number':
        case 'bigint':
          {
            switch (value) {
              case _stellarBase.xdr.ScSpecType.scSpecTypeU32().value:
                return _stellarBase.xdr.ScVal.scvU32(val);
              case _stellarBase.xdr.ScSpecType.scSpecTypeI32().value:
                return _stellarBase.xdr.ScVal.scvI32(val);
              case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value:
              case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value:
              case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value:
              case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value:
              case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value:
              case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value:
                {
                  var intType = t.name.substring(10).toLowerCase();
                  return new _stellarBase.XdrLargeInt(intType, val).toScVal();
                }
              default:
                throw new TypeError("invalid type (".concat(ty, ") specified for integer"));
            }
          }
        case 'string':
          return stringToScVal(val, t);
        case 'boolean':
          {
            if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeBool().value) {
              throw TypeError("Type ".concat(ty, " was not bool, but value was bool"));
            }
            return _stellarBase.xdr.ScVal.scvBool(val);
          }
        case 'undefined':
          {
            if (!ty) {
              return _stellarBase.xdr.ScVal.scvVoid();
            }
            switch (value) {
              case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value:
              case _stellarBase.xdr.ScSpecType.scSpecTypeOption().value:
                return _stellarBase.xdr.ScVal.scvVoid();
              default:
                throw new TypeError("Type ".concat(ty, " was not void, but value was undefined"));
            }
          }
        case 'function':
          return this.nativeToScVal(val(), ty);
        default:
          throw new TypeError("failed to convert typeof ".concat(_typeof(val), " (").concat(val, ")"));
      }
    }
  }, {
    key: "nativeToUdt",
    value: function nativeToUdt(val, name) {
      var entry = this.findEntry(name);
      switch (entry.switch()) {
        case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
          if (typeof val !== 'number') {
            throw new TypeError("expected number for enum ".concat(name, ", but got ").concat(_typeof(val)));
          }
          return this.nativeToEnum(val, entry.value());
        case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
          return this.nativeToStruct(val, entry.value());
        case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
          return this.nativeToUnion(val, entry.value());
        default:
          throw new Error("failed to parse udt ".concat(name));
      }
    }
  }, {
    key: "nativeToUnion",
    value: function nativeToUnion(val, union_) {
      var _this3 = this;
      var entry_name = val.tag;
      var case_ = union_.cases().find(function (entry) {
        var case_ = entry.value().name().toString();
        return case_ === entry_name;
      });
      if (!case_) {
        throw new TypeError("no such enum entry: ".concat(entry_name, " in ").concat(union_));
      }
      var key = _stellarBase.xdr.ScVal.scvSymbol(entry_name);
      switch (case_.switch()) {
        case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0():
          {
            return _stellarBase.xdr.ScVal.scvVec([key]);
          }
        case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0():
          {
            var types = case_.value().type();
            if (Array.isArray(val.values)) {
              if (val.values.length != types.length) {
                throw new TypeError("union ".concat(union_, " expects ").concat(types.length, " values, but got ").concat(val.values.length));
              }
              var scvals = val.values.map(function (v, i) {
                return _this3.nativeToScVal(v, types[i]);
              });
              scvals.unshift(key);
              return _stellarBase.xdr.ScVal.scvVec(scvals);
            }
            throw new Error("failed to parse union case ".concat(case_, " with ").concat(val));
          }
        default:
          throw new Error("failed to parse union ".concat(union_, " with ").concat(val));
      }
    }
  }, {
    key: "nativeToStruct",
    value: function nativeToStruct(val, struct) {
      var _this4 = this;
      var fields = struct.fields();
      if (fields.some(isNumeric)) {
        if (!fields.every(isNumeric)) {
          throw new Error('mixed numeric and non-numeric field names are not allowed');
        }
        return _stellarBase.xdr.ScVal.scvVec(fields.map(function (_, i) {
          return _this4.nativeToScVal(val[i], fields[i].type());
        }));
      }
      return _stellarBase.xdr.ScVal.scvMap(fields.map(function (field) {
        var name = field.name().toString();
        return new _stellarBase.xdr.ScMapEntry({
          key: _this4.nativeToScVal(name, _stellarBase.xdr.ScSpecTypeDef.scSpecTypeSymbol()),
          val: _this4.nativeToScVal(val[name], field.type())
        });
      }));
    }
  }, {
    key: "nativeToEnum",
    value: function nativeToEnum(val, enum_) {
      if (enum_.cases().some(function (entry) {
        return entry.value() === val;
      })) {
        return _stellarBase.xdr.ScVal.scvU32(val);
      }
      throw new TypeError("no such enum entry: ".concat(val, " in ").concat(enum_));
    }
  }, {
    key: "scValStrToNative",
    value: function scValStrToNative(scv, typeDef) {
      return this.scValToNative(_stellarBase.xdr.ScVal.fromXDR(scv, 'base64'), typeDef);
    }
  }, {
    key: "scValToNative",
    value: function scValToNative(scv, typeDef) {
      var _this5 = this;
      var t = typeDef.switch();
      var value = t.value;
      if (value === _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value) {
        return this.scValUdtToNative(scv, typeDef.value());
      }
      switch (scv.switch().value) {
        case _stellarBase.xdr.ScValType.scvVoid().value:
          return void 0;
        case _stellarBase.xdr.ScValType.scvU64().value:
        case _stellarBase.xdr.ScValType.scvI64().value:
        case _stellarBase.xdr.ScValType.scvU128().value:
        case _stellarBase.xdr.ScValType.scvI128().value:
        case _stellarBase.xdr.ScValType.scvU256().value:
        case _stellarBase.xdr.ScValType.scvI256().value:
          return (0, _stellarBase.scValToBigInt)(scv);
        case _stellarBase.xdr.ScValType.scvVec().value:
          {
            if (value == _stellarBase.xdr.ScSpecType.scSpecTypeVec().value) {
              var _scv$vec;
              var vec = typeDef.value();
              return ((_scv$vec = scv.vec()) !== null && _scv$vec !== void 0 ? _scv$vec : []).map(function (elm) {
                return _this5.scValToNative(elm, vec.elementType());
              });
            } else if (value == _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value) {
              var _scv$vec2;
              var tuple = typeDef.value();
              var valTypes = tuple.valueTypes();
              return ((_scv$vec2 = scv.vec()) !== null && _scv$vec2 !== void 0 ? _scv$vec2 : []).map(function (elm, i) {
                return _this5.scValToNative(elm, valTypes[i]);
              });
            }
            throw new TypeError("Type ".concat(typeDef, " was not vec, but ").concat(scv, " is"));
          }
        case _stellarBase.xdr.ScValType.scvAddress().value:
          return _stellarBase.Address.fromScVal(scv);
        case _stellarBase.xdr.ScValType.scvMap().value:
          {
            var _scv$map;
            var map = (_scv$map = scv.map()) !== null && _scv$map !== void 0 ? _scv$map : [];
            if (value == _stellarBase.xdr.ScSpecType.scSpecTypeMap().value) {
              var type_ = typeDef.value();
              var keyType = type_.keyType();
              var valueType = type_.valueType();
              return new Map(map.map(function (entry) {
                return [_this5.scValToNative(entry.key(), keyType), _this5.scValToNative(entry.val(), valueType)];
              }));
            }
            throw new TypeError("ScSpecType ".concat(t.name, " was not map, but ").concat(JSON.stringify(scv, null, 2), " is"));
          }
        case _stellarBase.xdr.ScValType.scvBool().value:
        case _stellarBase.xdr.ScValType.scvU32().value:
        case _stellarBase.xdr.ScValType.scvI32().value:
        case _stellarBase.xdr.ScValType.scvBytes().value:
          return scv.value();
        case _stellarBase.xdr.ScValType.scvString().value:
        case _stellarBase.xdr.ScValType.scvSymbol().value:
          {
            var _scv$value;
            if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeString().value && value !== _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value) {
              throw new Error("ScSpecType ".concat(t.name, " was not string or symbol, but ").concat(JSON.stringify(scv, null, 2), " is"));
            }
            return (_scv$value = scv.value()) === null || _scv$value === void 0 ? void 0 : _scv$value.toString();
          }
        case _stellarBase.xdr.ScValType.scvTimepoint().value:
        case _stellarBase.xdr.ScValType.scvDuration().value:
          return (0, _stellarBase.scValToBigInt)(_stellarBase.xdr.ScVal.scvU64(scv.value()));
        default:
          throw new TypeError("failed to convert ".concat(JSON.stringify(scv, null, 2), " to native type from type ").concat(t.name));
      }
    }
  }, {
    key: "scValUdtToNative",
    value: function scValUdtToNative(scv, udt) {
      var entry = this.findEntry(udt.name().toString());
      switch (entry.switch()) {
        case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
          return this.enumToNative(scv, entry.value());
        case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
          return this.structToNative(scv, entry.value());
        case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
          return this.unionToNative(scv, entry.value());
        default:
          throw new Error("failed to parse udt ".concat(udt.name().toString(), ": ").concat(entry));
      }
    }
  }, {
    key: "unionToNative",
    value: function unionToNative(val, udt) {
      var vec = val.vec();
      if (!vec) {
        throw new Error("".concat(JSON.stringify(val, null, 2), " is not a vec"));
      }
      if (vec.length === 0 && udt.cases.length !== 0) {
        throw new Error("".concat(val, " has length 0, but the there are at least one case in the union"));
      }
      var name = vec[0].sym().toString();
      if (vec[0].switch().value != _stellarBase.xdr.ScValType.scvSymbol().value) {
        throw new Error("{vec[0]} is not a symbol");
      }
      var entry = udt.cases().find(findCase(name));
      if (!entry) {
        throw new Error("failed to find entry ".concat(name, " in union {udt.name().toString()}"));
      }
      var res = {
        tag: name,
        values: undefined
      };
      if (entry.switch().value === _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value) {
        var tuple = entry.value();
        var ty = tuple.type();
        var values = [];
        for (var i = 0; i < ty.length; i++) {
          var v = this.scValToNative(vec[i + 1], ty[i]);
          values.push(v);
        }
        var r = {
          tag: name,
          values: values
        };
        return r;
      }
      return res;
    }
  }, {
    key: "structToNative",
    value: function structToNative(val, udt) {
      var _this6 = this,
        _val$map;
      var res = {};
      var fields = udt.fields();
      if (fields.some(isNumeric)) {
        var _val$vec;
        var r = (_val$vec = val.vec()) === null || _val$vec === void 0 ? void 0 : _val$vec.map(function (entry, i) {
          return _this6.scValToNative(entry, fields[i].type());
        });
        return r;
      }
      (_val$map = val.map()) === null || _val$map === void 0 || _val$map.forEach(function (entry, i) {
        var field = fields[i];
        res[field.name().toString()] = _this6.scValToNative(entry.val(), field.type());
      });
      return res;
    }
  }, {
    key: "enumToNative",
    value: function enumToNative(scv, udt) {
      if (scv.switch().value !== _stellarBase.xdr.ScValType.scvU32().value) {
        throw new Error("Enum must have a u32 value");
      }
      var num = scv.value();
      if (udt.cases().some(function (entry) {
        return entry.value() === num;
      })) {}
      return num;
    }
  }]);
  return ContractSpec;
}();
function stringToScVal(str, ty) {
  switch (ty.value) {
    case _stellarBase.xdr.ScSpecType.scSpecTypeString().value:
      return _stellarBase.xdr.ScVal.scvString(str);
    case _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value:
      return _stellarBase.xdr.ScVal.scvSymbol(str);
    case _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value:
      {
        var addr = _stellarBase.Address.fromString(str);
        return _stellarBase.xdr.ScVal.scvAddress(addr.toScAddress());
      }
    default:
      throw new TypeError("invalid type ".concat(ty.name, " specified for string value"));
  }
}
function isNumeric(field) {
  return /^\d+$/.test(field.name().toString());
}
function findCase(name) {
  return function matches(entry) {
    switch (entry.switch().value) {
      case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value:
        {
          var tuple = entry.value();
          return tuple.name().toString() === name;
        }
      case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value:
        {
          var void_case = entry.value();
          return void_case.name().toString() === name;
        }
      default:
        return false;
    }
  };
}
function readObj(args, input) {
  var inputName = input.name().toString();
  var entry = Object.entries(args).find(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      name = _ref2[0],
      _ = _ref2[1];
    return name === inputName;
  });
  if (!entry) {
    throw new Error("Missing field ".concat(inputName));
  }
  return entry[1];
}